#!/bin/bash

# For regular jobs, the Job ID is sufficient. However, for array jobs,
# we need to reconstruct the special array job ID and set the Job ID
# to that. If we're not in a job, use a default.
JID=${SLURM_JOB_ID}
AID=${SLURM_ARRAY_JOB_ID}
TID=${SLURM_ARRAY_TASK_ID}
if [ ! -z $AID ] && [ ! -z $TID ]; then
  JID=`echo sps-${AID}_${TID}`
elif [ ! -z $JID ]; then
  JID=`echo sps-$JID`
else
  JID=`echo sps`
fi

# We can now kill SPS by PID
SPSLOG="${JID}.log"
SPSPID=`grep SPS_PROCESS $SPSLOG | awk '{print $2}'`
if [ -z $SPSPID ]; then
  # SPS broke. Bail out.
  echo No SPS proccess ID found in log. Something went wrong.
  exit 1
fi
# Double check that this PID hasn't been reused for something else. Then
# kill it.
PIDCOMM=`ps -p $SPSPID -h -o comm`
if [ ! -z $PIDCOMM ] && [ $PIDCOMM == "sps" ]; then
  kill $SPSPID
fi

fix_output () {
  OUT="${JID}-${1}.tsv"
  BAK="${OUT}.bak"
  # If we got killed in the middle of a rewrite, there may be a backup file
  if [ -f $BAK ]; then
    # There might also be a normal file. If so, it's corrupt.
    if [ -f $OUT ]; then
      rm -f $OUT 
    fi
    # Either way there isn't now, so restore the backup.
    mv $BAK $OUT 
  fi

  # If it all went horribly wrong, there may be no output either
  if [ ! -f $OUT ]; then
    echo "No output $OUT found."
    return 1
  fi

  # If we got killed in the middle of an append, the last line may be corrupt.
  # There's no simple way to know if this happens as it could be in the last
  # number on the line, so the simplest thing is just to throw away the very
  # last line.
  sed -i '$d' $OUT
}

fix_output "cpu" &
fix_output "mem" &
fix_output "read" &
fix_output "write" &

wait # For background tasks
